const B=(e,t)=>t.some(n=>e instanceof n);let k,g;function x(){return k||(k=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function A(){return g||(g=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const w=new WeakMap,l=new WeakMap,b=new WeakMap;function S(e){const t=new Promise((n,o)=>{const i=()=>{e.removeEventListener("success",c),e.removeEventListener("error",r)},c=()=>{n(u(e.result)),i()},r=()=>{o(e.error),i()};e.addEventListener("success",c),e.addEventListener("error",r)});return b.set(t,e),t}function V(e){if(w.has(e))return;const t=new Promise((n,o)=>{const i=()=>{e.removeEventListener("complete",c),e.removeEventListener("error",r),e.removeEventListener("abort",r)},c=()=>{n(),i()},r=()=>{o(e.error||new DOMException("AbortError","AbortError")),i()};e.addEventListener("complete",c),e.addEventListener("error",r),e.addEventListener("abort",r)});w.set(e,t)}let D={get(e,t,n){if(e instanceof IDBTransaction){if(t==="done")return w.get(e);if(t==="store")return n.objectStoreNames[1]?void 0:n.objectStore(n.objectStoreNames[0])}return u(e[t])},set(e,t,n){return e[t]=n,!0},has(e,t){return e instanceof IDBTransaction&&(t==="done"||t==="store")?!0:t in e}};function L(e){D=e(D)}function j(e){return A().includes(e)?function(...t){return e.apply(I(this),t),u(this.request)}:function(...t){return u(e.apply(I(this),t))}}function p(e){return typeof e=="function"?j(e):(e instanceof IDBTransaction&&V(e),B(e,x())?new Proxy(e,D):e)}function u(e){if(e instanceof IDBRequest)return S(e);if(l.has(e))return l.get(e);const t=p(e);return t!==e&&(l.set(e,t),b.set(t,e)),t}const I=e=>b.get(e);function O(e,t,{blocked:n,upgrade:o,blocking:i,terminated:c}={}){const r=indexedDB.open(e,t),f=u(r);return o&&r.addEventListener("upgradeneeded",s=>{o(u(r.result),s.oldVersion,s.newVersion,u(r.transaction),s)}),n&&r.addEventListener("blocked",s=>n(s.oldVersion,s.newVersion,s)),f.then(s=>{c&&s.addEventListener("close",()=>c()),i&&s.addEventListener("versionchange",a=>i(a.oldVersion,a.newVersion,a))}).catch(()=>{}),f}const T=["get","getKey","getAll","getAllKeys","count"],v=["put","add","delete","clear"],y=new Map;function P(e,t){if(!(e instanceof IDBDatabase&&!(t in e)&&typeof t=="string"))return;if(y.get(t))return y.get(t);const n=t.replace(/FromIndex$/,""),o=t!==n,i=v.includes(n);if(!(n in(o?IDBIndex:IDBObjectStore).prototype)||!(i||T.includes(n)))return;const c=async function(r,...f){const s=this.transaction(r,i?"readwrite":"readonly");let a=s.store;return o&&(a=a.index(f.shift())),(await Promise.all([a[n](...f),i&&s.done]))[0]};return y.set(t,c),c}L(e=>({...e,get:(t,n,o)=>P(t,n)||e.get(t,n,o),has:(t,n)=>!!P(t,n)||e.has(t,n)}));const N=["continue","continuePrimaryKey","advance"],E={},m=new WeakMap,C=new WeakMap,W={get(e,t){if(!N.includes(t))return e[t];let n=E[t];return n||(n=E[t]=function(...o){m.set(this,C.get(this)[t](...o))}),n}};async function*F(...e){let t=this;if(t instanceof IDBCursor||(t=await t.openCursor(...e)),!t)return;t=t;const n=new Proxy(t,W);for(C.set(n,t),b.set(n,I(t));t;)yield n,t=await(m.get(n)||t.continue()),m.delete(n)}function M(e,t){return t===Symbol.asyncIterator&&B(e,[IDBIndex,IDBObjectStore,IDBCursor])||t==="iterate"&&B(e,[IDBIndex,IDBObjectStore])}L(e=>({...e,get(t,n,o){return M(t,n)?F:e.get(t,n,o)},has(t,n){return M(t,n)||e.has(t,n)}}));const K="TeoVozDB",R=1;let h;const d=()=>(h||(h=O(K,R,{upgrade(e){e.objectStoreNames.contains("books")||e.createObjectStore("books",{keyPath:"id"})}})),h),_=async e=>(await d()).put("books",e),z=async e=>(await d()).get("books",e),$=async()=>(await d()).getAll("books"),G=async e=>(await d()).delete("books",e),H=async()=>(await d()).clear("books"),J=async(e,t)=>{const n=await d(),o=await n.get("books",e);o&&(o.lastPosition=t,await n.put("books",o))};export{H as deleteAllBooks,G as deleteBook,$ as getAllBooks,z as getBook,d as initDB,_ as saveBook,J as updateBookPosition};
